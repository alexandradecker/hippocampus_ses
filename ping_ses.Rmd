---
title: "ping_ses"
output: html_notebook
editor_options: 
  chunk_output_type: console
---
 
#### Analyses to asses the relationship between income and episodic memory and language ####
test 2
The relationship between income and episodic memory was tested using a linear model. The log of income was the predictor variable, and the dependent variable was episodic memory scores. Age and sex were included as covariates. Age was mean centered ad sex was effect coded.

```{r}
hist(pingSubset$income)
hist(pingSubset$income3)
pingSubset[, income3C := income3 - mean(income3)]
hist(pingSubset$income3C)
pingSubset$logIncome3C <- NULL
pingSubset[!is.na(income3C), logIncome3C := log(income3C)]
hist(pingSubset$logIncome3)

#income - episodic memory model 
logIncome_memory <- lm(TBX_ibam_scr ~ logIncome3 + GenderEC + AgeC, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(logIncome_memory)
pingSubset$DeviceSerialNumber <- as.factor(pingSubset$DeviceSerialNumber)
pingSubset[, DeviceSerialNumber_test := DeviceSerialNumber]
pingSubset[, unique(DeviceSerialNumber_test)]
contrasts(pingSubset$DeviceSerialNumber) = contr.sum(7)

pingSubset[, TBX_ibam_scrZ := scale(TBX_ibam_scr)]
pingSubset[, mean(TBX_ibam_scrZ, na.rm=T)]
pingSubset[, var(TBX_ibam_scrZ, na.rm=T)]
pingSubset[, range(TBX_ibam_scrZ, na.rm=T)]

#An alternative compelling description could put this in terms of years. E.g.  

#memory performance of children in the lowest income bracket is comprable to wealthy children x.x years younger them. 

logIncome_memory_test <- lm(TBX_ibam_scrZ ~ logIncome3 + GenderEC + AgeC, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(logIncome_memory_test)

pingSubset$logIncome3_z
pingSubset$Age_z

pingSubset[, min(logIncome3)]
pingSubset[, max(logIncome3)]

#now for language. How far apart are lowest and highest income groups?

logIncome_vocab_test <- lm(vocab_z ~ logIncome3 + GenderEC + AgeC, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(logIncome_vocab_test)

pingSubset$logIncome3_z
pingSubset$Age_z

pingSubset[, min(logIncome3)]
pingSubset[, max(logIncome3)]
pingSubset$vocab_z


#summary of results relating income to episodic memory scores
summary(logIncome_memory)
anova(logIncome_memory)
scanners <- pingFull[, .N, by = .(DeviceSerialNumber,ManufacturersModelName,  Manufacturer)]%>%print(n=30)

scanners[DeviceSerialNumber == "e", Site:="Weill Cornell Medical College"]
grep(names(pingSubset), pattern = "Site", value =T)

names(pingSubset)[1:30]

#how different are those from poorest and richest?
unique(pingSubset$logIncome3)
unique(pingSubset$income3)

#use z scores to determine for every 1 sd in income, what sd in performance... 
grep(names(pingSubset), pattern = "z", Value = T)
grep(x = names(pingSubset), pattern = "Z", value = T)
pingSubset$episodic_zscores
pingSubset$vocab_z
pingSubset[, logIncome3_z := scale(logIncome3)]
pingSubset[, mean(logIncome3, na.rm=T)]
pingSubset[, sd(logIncome3)]
pingSubset[, logIncome3, logIncome3_z]
pingSubset[, .N, by = .(logIncome3_z, logIncome3, income3)]%>%arrange(logIncome3_z)
pingSubset[, mean(income3)]
pingSubset[, mean(logIncome3)]

#rerun model on standardized, z scored values
pingSubset[, Age_z := scale(Age)]
pingSubset[, mean(Age)]
pingSubset[, sd(Age)]
pingSubset[, .(Age, Age_z)]

logIncome_memory_z <- lm(episodic_zscores ~ logIncome3_z + GenderEC + Age_z, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(logIncome_memory_z)
pingSubset[, .N, by = .(logIncome3_z, logIncome3, income3)]%>%arrange(logIncome3_z)

Income_memory_z <- lm(episodic_zscores ~ income3_z + GenderEC + Age_z, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(Income_memory_z)
pingSubset[, .N, by = .(logIncome3_z, logIncome3, income3, income3_z)]%>%arrange(logIncome3_z)

pingSubset[, var(logIncome3_z)]

logIncome_vocab_z <- lm(vocab_z ~ logIncome3_z + GenderEC + AgeC, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(logIncome_vocab_z)
pingSubset[, .N, by = .(logIncome3_z, logIncome3, income3)]%>%arrange(logIncome3_z)

#lowest and highest group are 4.44z scores in log income apart
#for every 1 sd in income, get .2 sd in episodic memory
incomeEpisodic <- 4.44*0.206032
incomeVocab <- 4.44 * 0.325759

summary(logIncome_memory_z)
summary(Income_memory)

```

The relationship between income and language abilities was tested using a linear model. Vocabulary scores were used as the dependent variable, and the log of income was used as the predictor variable. Age (mean centered) and sex (effect coded) were included as covariates.

```{r}

#income - language ability model 
logIncome_vocab <- lm(TBX_VOCAB_THETA ~ logIncome3 + GenderEC + AgeC, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])

#summary of results relating income to episodic memory scores
summary(logIncome_vocab)
pingSubset[, Gender, GenderEC]
pingSubset[, mean(TBX_VOCAB_THETA, na.rm=T), by = GenderEC]
pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO) & !is.na(TBX_ibam_scr), .N]

```


#### Analyses to assess whether income correlates with anterior or posterior hippocampal volumes ####

The relationship between income and regional hippocampal volumes was tested using a linear model. Two  linear regression models were constructed, in which anterior and posterior hippocampal volumes were dependent variables in separate models. The log of family income was used as the predictor in both models. Both models included age (mean centered), sex (effect coded), and scanner number (dummy coded) as covariates.

We also constructed a third model that included the whole hippocampus as a dependent variable to test whether income predicted whole hippocampal volumes. 

```{r}

#income - anterior hippocampal volume model
income_anterior <- lm(combinedHeadNewRO ~ logIncome3 + AgeC + GenderEC  +  DeviceSerialNumber, data = pingSubset[!is.na(combinedPosteriorNewRO)])
pingSubset$DeviceSerialNumber_test <- relevel(pingSubset$DeviceSerialNumber, ref = "a")

#summary of results from income-anterior hippocampal volume model
summary(income_anterior)

#z score model for anterior and income
income_anteriorz <- lm(anterior_z ~ logIncome3 + AgeC + GenderEC  +  DeviceSerialNumber, data = pingSubset[!is.na(combinedPosteriorNewRO)])

#summary of results from income-anterior hippocampal volume model
summary(income_anteriorz)


pingSubset[, range(logIncome3)]

#income - posterior hippocampal volume model
income_posterior <- lm(combinedPosteriorNewRO ~ logIncome3 + AgeC + GenderEC  +  DeviceSerialNumber, data = pingSubset[!is.na(combinedHeadNewRO)])

#summary of results from income-anterior hippocampal volume model
summary(income_posterior)


#income - whole hippocampal volume model
income_whole <- lm(hippo.Whole.Avg ~ logIncome3 + AgeC + GenderEC  +  DeviceSerialNumber, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])

#summary of results from income-anterior hippocampal volume model
summary(income_whole)

```

#does income have a larger influence on the volume of the anterior than posterior hippocampus?

To test this, we constructed an interaction model, in which volumes was the dependent variable, and region (anterior, posterior), and income, were predictors and interaction terms. The interaction term tests whether the effect of income on volumes depends on the region (anterior vs. posterior). Age (mean centered), sex (effect coded), and scanner number (dummy coded), were included as covariates.

Do volume differences ebtween income levels depend on whether it's anterior or posterior?
* difference between anova and lmer test because anova gives omnibus and summary compares each level... 
eg: how does income overall affect volumes vs. how does income affect anterior relative to posterior?

```{r}
dfLong <- gather(toGather, region, volume, -c(ID, AgeC, logIncome3, GenderEC, DeviceSerialNumber))

#does income effect volume differently in anterior vs. posterior hippocampus? 
interaction_income_region <- lmer(volume ~  logIncome3 * region  + AgeC + GenderEC +  DeviceSerialNumber  +(1|ID), data = dfLong)
anova(interaction_income_region,type = 3)

summary(interaction_income_region)

interaction_income_region_2 <- lmer(volume ~  logIncome3 * region  + AgeC + GenderEC +  DeviceSerialNumber  +(1|region), data = dfLong)
anova(interaction_income_region,type = 3)
summary(interaction_income_region_2)

MuMIn::r.squaredGLMM(interaction_income_region_2) 

install.packages("MuMIn")

```



```{r}

dfLong[, n_distinct(ID)]
#allowing participants intercept to vary, but assuming the slope is the same
summaryh(lmer(volume ~ region * logIncome3 + AgeC + GenderEC +  DeviceSerialNumber + (1|ID), data = dfLong))

#this is asking whether one is more influenced than another...
summary(lm(logIncome3 ~ combinedHeadNewRO + combinedPosteriorNewRO + AgeC + GenderEC + DeviceSerialNumber, data = pingSubset))
summary(lm(income3 ~ combinedHeadNewRO + combinedPosteriorNewRO + AgeC + GenderEC + DeviceSerialNumber, data = pingSubset))



pingSubset[!is.na(TBX_ibam_scr), .N]
pingSubset[!is.na(TBX_VOCAB_THETA), .N]
pingSubset[, .(DeviceSerialNumber, logIncome3)]


```

#### Analyses to assess whether volumes predict episodic memory and language abilities ####


```{r}
summary(lm(TBX_ibam_scr ~ combinedHeadNewRO + logIncome3 + AgeC + GenderEC, data = pingSubset[!is.na(combinedPosteriorNewRO)]))

summary(lm(TBX_ibam_scr ~ combinedPosteriorNewRO + logIncome3 + AgeC + GenderEC, data = pingSubset[!is.na(combinedHeadNewRO)]))

summary(lm(TBX_VOCAB_THETA ~ combinedHeadNewRO + logIncome3 + AgeC + GenderEC, data = pingSubset[!is.na(combinedPosteriorNewRO)]))

summary(lm(TBX_VOCAB_THETA ~ combinedPosteriorNewRO + logIncome3 + AgeC + GenderEC, data = pingSubset[!is.na(combinedHeadNewRO)]))

pingSubset[, Gender, GenderEC]
```

#### do volumes mediate the relationship between income and cognitive performance ####
#for anterior hippocampal volumes only
```{r}

#third
#mediation model
model.y_episodic <- lm(TBX_ibam_scr ~ combinedHeadNewRO + GenderEC + AgeC + logIncome3, data = pingSubset[!is.na(combinedPosteriorNewRO)])
summary(model.y_episodic)

model.m_episodic <- lm(combinedHeadNewRO ~logIncome3 + AgeC + DeviceSerialNumber + GenderEC, data = pingSubset[!is.na(TBX_ibam_scr) & !is.na(combinedPosteriorNewRO)])
summary(model.m_episodic)

model.mediate_episodic <- mediate(model.m = model.m_episodic, model.y = model.y_episodic, sims = 5000, treat = "logIncome3", mediator = "combinedHeadNewRO",boot = TRUE)
summary(model.mediate_episodic)

# controlling for scanner serial number in both  (as per Katherine's suggestion)

model.y_episodic_ssn <- lm(TBX_ibam_scr ~ combinedHeadNewRO + GenderEC + AgeC + logIncome3 + DeviceSerialNumber, data = pingSubset[!is.na(combinedPosteriorNewRO)])
summary(model.y_episodic_ssn)

model.m_episodic_ssn <- lm(combinedHeadNewRO ~logIncome3 + AgeC + DeviceSerialNumber + GenderEC, data = pingSubset[!is.na(TBX_ibam_scr) & !is.na(combinedPosteriorNewRO)])
summary(model.m_episodic_ssn)

model.mediate_episodic_ssc <- mediate(model.m = model.m_episodic_ssn, model.y = model.y_episodic_ssn, sims = 5000, treat = "logIncome3", mediator = "combinedHeadNewRO",boot = TRUE,)
summary(model.mediate_episodic_ssc)

standard.errors(model.mediate_episodic_ssc)

#acme: mediated (ab) effect
#ade: direct effect (c')
#total effect: c


# z scored version
pingSubset[!is.na(TBX_ibam_scr), episodic_z := scale(TBX_ibam_scr)]
pingSubset[, var(episodic_z, na.rm=T)]
pingSubset[!is.na(TBX_VOCAB_THETA), vocab_z := scale(TBX_VOCAB_THETA)]
pingSubset[, mean(vocab_z, na.rm=T)]
pingSubset[!is.na(Age), Age_z := scale(Age)]
pingSubset[!is.na(logIncome3), logIncome3_z := scale(logIncome3)]
pingSubset[, mean(logIncome3_z)]
pingSubset[!is.na(combinedPosteriorNewRO), posterior_z := scale(combinedPosteriorNewRO)]
pingSubset[!is.na(combinedHeadNewRO), anterior_z := scale(combinedHeadNewRO)]
pingSubset[, var(anterior_z, na.rm=T)]
pingSubset[, var(posterior_z, na.rm=T)]
pingSubset[!is.na(hippo.Whole.Avg), whole_z := scale(hippo.Whole.Avg)]



model.y_episodic_z <- lm(episodic_z ~ anterior_z + GenderEC + Age_z + logIncome3_z + DeviceSerialNumber2, data = pingSubset[!is.na(combinedPosteriorNewRO)])
summary(model.y_episodic_z)

model.m_episodic_z <- lm(anterior_z ~logIncome3_z + Age_z + DeviceSerialNumber2 + GenderEC, data = pingSubset[!is.na(TBX_ibam_scr) & !is.na(combinedPosteriorNewRO)])
summary(model.m_episodic_z)

model.mediate_episodic_z <- mediate(model.m = model.m_episodic_z, model.y = model.y_episodic_z, sims = 5000, treat = "logIncome3_z", mediator = "anterior_z",boot = TRUE, covariates = c("GenderEC", "Age_z", "DeviceSerialNumber2"))

summary(model.mediate_episodic_z)
standard.errors(model.mediate_episodic_z)
#acme: mediated (ab) effect
#ade: direct effect (c')
#total effect: c




#vocab z
model.y_vocab_z <- lm(vocab_z ~ anterior_z + GenderEC + Age_z + logIncome3_z + DeviceSerialNumber2, data = pingSubset[!is.na(combinedPosteriorNewRO)])
summary(model.y_vocab_z)

model.m_vocab_z <- lm(anterior_z ~logIncome3_z + Age_z + DeviceSerialNumber2 + GenderEC, data = pingSubset[!is.na(TBX_ibam_scr) & !is.na(combinedPosteriorNewRO)])
summary(model.m_vocab_z)

model.mediate_vocab_z <- mediate(model.m = model.m_vocab_z, model.y = model.y_vocab_z, sims = 5000, treat = "logIncome3_z", mediator = "anterior_z",boot = TRUE, covariates = c("GenderEC", "Age_z", "DeviceSerialNumber2"))

summary(model.mediate_vocab_z)
summary(model.mediate_episodic_z)

standard.errors(model.mediate_vocab_z)


#acme: mediated (ab) effect
#ade: direct effect (c')
#total effect: c

"This analysis revealed that group affected mean accuracy as a function of its relationship with percent out, ab =-0.00650, SE = 0.001897814 , 95% CI [-0.01045, 0]. Although the total effect of percent out on accuracy was significant, c = -0.01068, SE = 0.002168114 , 95% CI [-0.01503,  -0.01], 
the direct effect of group on accuracy was not significant when the indirect path through 
percent out was taken into account, c’ = -0.00419 , SE = 0.002686647 , 95% CI [-0.00943,  0]. 
This analysis suggests that group predicts the acc because of its co-occurrence with percent out.”"


# vocab
model.y_vocab <- lm(TBX_VOCAB_THETA ~ combinedHeadNewRO + GenderEC + AgeC + logIncome3, data = pingFull[!is.na(combinedPosteriorNewRO)])
summary(model.y_vocab)

model.m_vocab <- lm(combinedHeadNewRO ~logIncome3 + AgeC + DeviceSerialNumber + GenderEC, data = pingSubset[!is.na(TBX_VOCAB_THETA) & !is.na(combinedPosteriorNewRO)])
summary(model.m_vocab)

model.mediate_vocab <- mediate(model.m = model.m_vocab, model.y = model.y_vocab, sims = 5000, treat = "logIncome3", mediator = "combinedHeadNewRO", boot = T)
summary(model.mediate_vocab)
standard.errors(model.mediate_vocab)

# with scanner serial number (as per katherine's suggestion)
model.y_vocab_ssn <- lm(TBX_VOCAB_THETA ~ combinedHeadNewRO + GenderEC + AgeC + logIncome3 + DeviceSerialNumber, data = pingFull[!is.na(combinedPosteriorNewRO)])
summary(model.y_vocab_ssn)

model.m_vocab_ssn <- lm(combinedHeadNewRO ~logIncome3 + AgeC + DeviceSerialNumber + GenderEC, data = pingSubset[!is.na(TBX_VOCAB_THETA) & !is.na(combinedPosteriorNewRO)])
summary(model.m_vocab_ssn)

model.mediate_vocab_ssc <- mediate(model.m = model.m_vocab_ssn, model.y = model.y_vocab_ssn, sims = 5000, treat = "logIncome3", mediator = "combinedHeadNewRO", boot = T)
summary(model.mediate_vocab_ssc)
standard.errors(model.mediate_vocab_ssc)


#z scored version

model.y_vocab_z <- lm(TBX_VOCAB_THETA_z ~ combinedHeadNewRO_z + GenderEC + Age_z + logIncome3_z, data = pingSubset[!is.na(combinedPosteriorNewRO)])
summary(model.y_vocab_z)

model.m_vocab_z<- lm(combinedHeadNewRO_z ~logIncome3_z + Age_z + DeviceSerialNumber + GenderEC, data = pingSubset[!is.na(TBX_VOCAB_THETA) & !is.na(combinedPosteriorNewRO)])
summary(model.m_vocab_z)

model.mediate_vocab_z <- mediate(model.m = model.m_vocab_z, model.y = model.y_vocab_z, sims = 5000, treat = "logIncome3_z", mediator = "combinedHeadNewRO_z")


summary(model.m_vocab)
lm.beta(model.m_vocab)

summary(model.y_vocab)
lm.beta(model.y_vocab)
standard.errors(model.mediate_vocab_z)

library('lm.beta')

#acme: mediated (ab) effect
#ade: direct effect (c')
#total effect: c

"This analysis revealed that group affected mean accuracy as a function of its relationship with percent out, ab =-0.00650, SE = 0.001897814 , 95% CI [-0.01045, 0]. Although the total effect of percent out on accuracy was significant, c = -0.01068, SE = 0.002168114 , 95% CI [-0.01503,  -0.01], 
the direct effect of group on accuracy was not significant when the indirect path through 
percent out was taken into account, c’ = -0.00419 , SE = 0.002686647 , 95% CI [-0.00943,  0]. 
This analysis suggests that group predicts the acc because of its co-occurrence with percent out.”"


```


#### do posterior hippocampal volumes mediate the relationship between income and episodic memory and language?


z version - posterior hipp

```{r}


#memory z
model.y_mem_z <- lm(episodic_z ~ posterior_z + GenderEC + Age_z + logIncome3_z + DeviceSerialNumber2, data = pingSubset[!is.na(combinedHeadNewRO)])
summary(model.y_mem_z)

model.m_mem_z <- lm(posterior_z ~logIncome3_z + Age_z + DeviceSerialNumber2 + GenderEC, data = pingSubset[!is.na(TBX_ibam_scr) & !is.na(combinedHeadNewRO)])
summary(model.m_mem_z)

model.mediate_mem_z <- mediate(model.m = model.m_mem_z, model.y = model.y_mem_z, sims = 5000, treat = "logIncome3_z", mediator = "posterior_z",boot = TRUE, covariates = c("GenderEC", "Age_z", "DeviceSerialNumber2"))

summary(model.mediate_mem_z)

standard.errors(model.mediate_mem_z)



#vocab z
model.y_vocab_z_post <- lm(vocab_z ~ posterior_z + GenderEC + Age_z + logIncome3_z + DeviceSerialNumber2, data = pingSubset[!is.na(combinedHeadNewRO)])
summary(model.y_vocab_z_post)

model.m_vocab_z_post <- lm(posterior_z ~logIncome3_z + Age_z + DeviceSerialNumber2 + GenderEC, data = pingSubset[!is.na(TBX_VOCAB_THETA) & !is.na(combinedHeadNewRO)])
summary(model.m_vocab_z_post)

model.mediate_vocab_z_post <- mediate(model.m = model.m_vocab_z_post, model.y = model.y_vocab_z_post, sims = 5000, treat = "logIncome3_z", mediator = "posterior_z",boot = TRUE, covariates = c("GenderEC", "Age_z", "DeviceSerialNumber2"))

summary(model.mediate_vocab_z_post)

standard.errors(model.mediate_vocab_z_post)

```




z version - whole hipp

```{r}

#memory z
model.y_mem_z_whole <- lm(episodic_z ~ whole_z + GenderEC + Age_z + logIncome3_z + DeviceSerialNumber2, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(model.y_mem_z_whole)

model.m_mem_z_whole <- lm(whole_z ~logIncome3_z + Age_z + DeviceSerialNumber2 + GenderEC, data = pingSubset[!is.na(TBX_ibam_scr) & !is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(model.m_mem_z_whole)

model.mediate_mem_z_whole <- mediate(model.m = model.m_mem_z_whole, model.y = model.y_mem_z_whole, sims = 5000, treat = "logIncome3_z", mediator = "whole_z",boot = TRUE, covariates = c("GenderEC", "Age_z", "DeviceSerialNumber2"))

summary(model.mediate_mem_z_whole)

standard.errors(model.mediate_mem_z_whole)




#vocab z
model.y_vocab_z_whole <- lm(vocab_z ~ whole_z + GenderEC + Age_z + logIncome3_z + DeviceSerialNumber2, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(model.y_vocab_z_whole)

model.m_vocab_z_whole <- lm(whole_z ~logIncome3_z + Age_z + DeviceSerialNumber2 + GenderEC, data = pingSubset[!is.na(TBX_VOCAB_THETA) & !is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(model.m_mem_z_whole)

model.mediate_vocab_z_whole <- mediate(model.m = model.m_vocab_z_whole, model.y = model.y_vocab_z_whole, sims = 5000, treat = "logIncome3_z", mediator = "whole_z",boot = TRUE, covariates = c("GenderEC", "Age_z", "DeviceSerialNumber2"))

summary(model.mediate_vocab_z_whole)
standard.errors(model.mediate_vocab_z_whole)






```



```{r}

model.y_episodic_posterior <- lm(TBX_ibam_scr ~ combinedPosteriorNewRO + GenderEC + AgeC +DeviceSerialNumber+ logIncome3, data = pingSubset[!is.na(combinedHeadNewRO)])
summary(model.y_episodic_posterior)

model.m_episodic_posterior <- lm(combinedPosteriorNewRO ~logIncome3 + AgeC + DeviceSerialNumber + GenderEC, data = pingSubset[!is.na(TBX_ibam_scr) & !is.na(combinedHeadNewRO)])
summary(model.m_episodic_posterior)

model.mediate_episodic_posterior <- mediate(model.m = model.m_episodic_posterior, model.y = model.y_episodic_posterior, sims = 5000, treat = "logIncome3", mediator = "combinedPosteriorNewRO",boot = TRUE)
summary(model.mediate_episodic_posterior)
standard.errors(model.mediate_episodic_posterior)

#acme: mediated (ab) effect
#ade: direct effect (c')
#total effect: c



###vocab and posterior mediation####

model.y_vocab_posterior <- lm(TBX_VOCAB_THETA ~ combinedPosteriorNewRO + GenderEC + AgeC +DeviceSerialNumber+ logIncome3, data = pingSubset[!is.na(combinedHeadNewRO)])
summary(model.y_vocab_posterior)

model.m_vocab_posterior <- lm(combinedPosteriorNewRO ~logIncome3 + AgeC + DeviceSerialNumber + GenderEC, data = pingSubset[!is.na(TBX_ibam_scr) & !is.na(combinedHeadNewRO)])
summary(model.m_vocab_posterior)

model.mediate_vocab_posterior <- mediate(model.m = model.m_vocab_posterior, model.y = model.y_vocab_posterior, sims = 5000, treat = "logIncome3", mediator = "combinedPosteriorNewRO",boot = TRUE)
summary(model.mediate_vocab_posterior)
standard.errors(model.mediate_vocab_posterior)

#acme: mediated (ab) effect
#ade: direct effect (c')
#total effect: c

```


####Do whole hippocampal volumes mediate the relationship between income and cognitive outcomes?####

```{r}
grep(x = names(pingSubset), value=T, pattern = "Avg")

model.y_episodic_whole <- lm(TBX_ibam_scr ~ hippo.Whole.Avg + GenderEC + AgeC +DeviceSerialNumber+ logIncome3, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(model.y_episodic_whole)

model.m_episodic_whole <- lm(hippo.Whole.Avg ~logIncome3 + AgeC + DeviceSerialNumber + GenderEC, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO) & !is.na(hippo.Whole.Avg) & !is.na(TBX_ibam_scr)])
summary(model.m_episodic_whole)

model.mediate_episodic_whole <- mediate(model.m = model.m_episodic_whole, model.y = model.y_episodic_whole, sims = 5000, treat = "logIncome3", mediator = "hippo.Whole.Avg",boot = TRUE)

summary(model.mediate_episodic_whole)
standard.errors(model.mediate_episodic_whole)


###vocab and whole mediation####

model.y_vocab_whole <- lm(TBX_VOCAB_THETA ~ hippo.Whole.Avg + GenderEC + AgeC + logIncome3 + DeviceSerialNumber_test, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO)])
summary(model.y_vocab_whole)

model.m_vocab_whole <- lm(hippo.Whole.Avg ~logIncome3 + AgeC  + GenderEC+ DeviceSerialNumber_test, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO) & !is.na(hippo.Whole.Avg) & !is.na(TBX_VOCAB_THETA)])
summary(model.m_vocab_whole)

model.mediate_vocab_whole1 <- mediate(model.m = model.y_vocab_whole, model.y = model.m_vocab_whole, sims = 5000, treat = "logIncome3", mediator = "hippo.Whole.Avg",boot = TRUE)

summary(model.mediate_vocab_whole1)
standard.errors(model.mediate_vocab_whole)

pingSubset[, DeviceSerialNumber_test]

```

```{r}
ggplot(pingSubset, aes(income, combinedHeadNewRO)) +
  stat_smooth(formula = y ~ x, method = 'lm') + 
 stat_summary(fun.y = mean, geom = "point", size = 1) +
   stat_summary(fun.data = mean_se, geom = "errorbar", width = 0, size = .6)

```

```{r}
ggplot(pingSubset, aes(income, combinedPosteriorNewRO)) +
  stat_smooth(formula = y ~ x, method = 'lm') + 
 stat_summary(fun.y = mean, geom = "point", size = 1) +
   stat_summary(fun.data = mean_se, geom = "errorbar", width = 0, size = .6)

```


```{r}
pingSubset[!is.na(TBX_ibam_scr), episodic_memory_residuals_age := residuals(lm(TBX_ibam_scr ~ AgeC))]
pingSubset[!is.na(TBX_VOCAB_THETA), vocab_residuals_age := residuals(lm(TBX_VOCAB_THETA ~ AgeC))]

grep(names(pingSubset), pattern = "resi", value  = TRUE)

ggplot(pingSubset, aes(income, episodic_memory_residuals_age)) +
  stat_smooth(formula = y ~ x, method = 'lm') + 
 stat_summary(fun.y = mean, geom = "point", size = 1) +
   stat_summary(fun.data = mean_se, geom = "errorbar", width = 0, size = .6)

summary(lm(TBX_ibam_scr ~ income + AgeC + GenderEC, data   = pingSubset[income < 11]))

ggplot(pingSubset, aes(income, vocab_residuals_age)) +
  stat_smooth(formula = y ~ x, method = 'lm') + 
 stat_summary(fun.y = mean, geom = "point", size = 1) +
   stat_summary(fun.data = mean_se, geom = "errorbar", width = 0, size = .6)

```


```{r}
summary(lm(TBX_ibam_scr ~ combinedPosteriorNewRO + combinedHeadNewRO + AgeC + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset))


summary(lm(TBX_ibam_scr ~  combinedHeadNewRO * AgeC + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset))
summary(lm(TBX_ibam_scr ~  combinedPosteriorNewRO * Age1 + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset))


```



#figures for paper

```{r}

pingSubset[, .(income, logIncome3, income, income1, income2, income3, Income, logIncome, logIncome3_sqrd,FDH_3_Household_Income )]
pingSubset[income3 == 325000, range(TBX_ibam_scr)]

grep(names(pingSubset), pattern = "income3", value = TRUE)

pingSubset[!is.na(TBX_ibam_scr), .N, by = income3]

ggplot(pingSubset, aes(income3, TBX_ibam_scr)) +
  geom_jitter(alpha = .3,show.legend = FALSE, size = 3, width = .95, height = .95)+
  geom_smooth(method = 'lm', formula = y ~ log(x), se = TRUE, shape =1) +
  labs(y = "Episodic memory performance", x = 'Income') + 
   theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 0.5, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 0.5, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 12, colour = 'black'), 
        axis.text.y = element_text(size = 15, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) +
    scale_x_continuous(breaks = c(4500, 15000, 25000,35000,  45000,  75000,125000, 175000, 225000,   275000, 325000), labels = c( "4,500","15000","25,000", "35,000","45,000", "75,000","125,000","175,000", "225,000","275000", "325,000"))
  


```


```{r}

grep(names(pingSubset), pattern = "resi", value = TRUE)
pingSubset[!is.na(TBX_ibam_scr),TBX_ibam_scr_residuals := residuals(lm(TBX_ibam_scr ~ GenderEC + AgeC))]

ggplot(pingSubset, aes(income3, TBX_ibam_scr_residuals)) +
  geom_jitter(show.legend = FALSE, size = 3, shape = 21)+
  geom_smooth(method = 'lm', formula = y ~ log(x), se = TRUE, shape =1) +
  labs(y = "Episodic memory performance", x = 'Income') + 
   theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 0.5, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 0.5, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 12, colour = 'black'), 
        axis.text.y = element_text(size = 15, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) +
    scale_x_continuous(breaks = c(4500, 45000,  75000,125000, 175000, 225000,   275000, 325000), labels = c( "4,500", "45,000", "75,000","125,000","175,000", "225,000","275,000", "325,000"))

pingSubset[, .(income3)]
```


#figure 1a

```{r}
episodic_residuals <- ggplot(pingSubset, aes(income3, TBX_ibam_scr_residuals)) +
  geom_jitter(show.legend = FALSE, size = 3, shape = 21)+
  geom_smooth(method = 'lm', formula = y ~ log(x), se = TRUE, shape =1, color = "purple") +
  labs(y = "Adjusted episodic memory \nperformance", x = 'Income (thousands, USD)') + 
   theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 16, colour = 'black'), 
        axis.text.y = element_text(size = 16, colour = 'black'), 
        plot.title = element_text(size = 16, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) +
    scale_x_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000, 300000, 350000), labels = c( "0", "50", "100", "150", "200", "250","300", "350"))


```


#z scores

```{r}
pingSubset[!is.na(TBX_ibam_scr), episodic_zscores := scale(TBX_ibam_scr_residuals)]

episodic_z <- ggplot(pingSubset, aes(income3, episodic_zscores)) +
  geom_jitter(show.legend = FALSE, size = 3, shape = 21)+
  geom_smooth(method = 'lm', formula = y ~ log(x), se = TRUE, shape =1, color = "purple") +
  labs(y = "Adjusted episodic memory \nperformance (z-scores)", x = 'Income (thousands, USD)') + 
   theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 16, colour = 'black'), 
        axis.text.y = element_text(size = 16, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) +
    scale_x_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000, 300000, 350000), labels = c( "0", "50", "100", "150", "200", "250","300", "350")) +
   scale_y_continuous(breaks=seq(-3, 4, 1))

```




#figure 1b

```{r}

pingSubset[!is.na(TBX_VOCAB_THETA), TBX_VOCAB_THETA_residuals := residuals(lm(TBX_VOCAB_THETA~ GenderEC + AgeC))]

vocab_residuals <- ggplot(pingSubset, aes(income3, TBX_VOCAB_THETA_residuals)) +
  geom_jitter(show.legend = FALSE, size = 3, shape = 21)+
  geom_smooth(method = 'lm', formula = y ~ log(x), se = TRUE, shape =1, color = "darkgreen") +
  labs(y = "Adjusted vocabulary \nperformance", x = 'Income (thousands, USD)') + 
   theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 16, colour = 'black'), 
        axis.text.y = element_text(size = 16, colour = 'black'), 
        plot.title = element_text(size = 16, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) +
    scale_x_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000, 300000, 350000), labels = c( "0", "50", "100", "150", "200", "250","300", "350"))


```



```{r}
pingSubset[!is.na(TBX_VOCAB_THETA_residuals), vocab_z := scale(TBX_VOCAB_THETA_residuals)]

vocab_z <- ggplot(pingSubset, aes(income3, vocab_z)) +
  geom_jitter(show.legend = FALSE, size = 3, shape = 21)+
  geom_smooth(method = 'lm', formula = y ~ log(x), se = TRUE, shape =1, color = "darkgreen") +
  labs(y = "Adjusted vocabulary \nperformance (z-scores)", x = 'Income (thousands, USD)') + 
   theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 16, colour = 'black'), 
        axis.text.y = element_text(size = 16, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) +
    scale_x_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000, 300000, 350000), labels = c( "0", "50", "100", "150", "200", "250","300", "350")) +
 scale_y_continuous(breaks=seq(-4, 4, 1))

```


#perform a chisqr test to see whether the counts in each income bin are different from the population

```{r}
pingSubset[!is.na(income3), .N]
percentIncomeSample <- pingSubset[!is.na(income3), .N, by = .(income, income2, income3)]
percentIncomeSample <- percentIncomeSample%>%arrange(income)
names(percentIncomeSample)[4] <- "Sample"

percentIncomeSample[income ==1, US_pop := .0367*710]
percentIncomeSample[income ==2, US_pop := .0347*710]
percentIncomeSample[income ==3, US_pop := .1087*710]
percentIncomeSample[income ==4, US_pop := .1062*710]
percentIncomeSample[income ==5, US_pop := .097*710]
percentIncomeSample[income ==6, US_pop := .0842*710]
percentIncomeSample[income ==7, US_pop := .2859*710]
percentIncomeSample[income ==8, US_pop := .1337*710]
percentIncomeSample[income ==9, US_pop := .0569*710]
percentIncomeSample[income ==10, US_pop := .0261*710]
percentIncomeSample[income ==11, US_pop := .014*710]
percentIncomeSample[income ==12, US_pop := .016*710]


sum(percentIncomeSample[, US_pop])
sum(percentIncomeSample[, Sample])

percentIncomeSample$income2 <-  as.factor(percentIncomeSample$income)
percentIncomeSample$US_pop <- round(percentIncomeSample$US_pop)

#create a table
c(percentIncomeSample$Sample, percentIncomeSample$US_pop)
incomeValues <- matrix(c(percentIncomeSample$Sample, percentIncomeSample$US_pop), ncol = 12, byrow = TRUE)
colnames(incomeValues) <- c(1:12)
rownames(incomeValues) <- c("Sample", "US_pop")

#perform a chisqr
#doesn't come from US population
income_x <- chisq.test(incomeValues)
income_x$observed 
income_x$expected 
 
```

#histogram

```{r}
mySampleRep <- rep("Sample", 710)
us_sample_rep <- rep("us_pop", 710)
sample <- c(mySampleRep, us_sample_rep)
incomeDt<- data.table(sample = c(sample))

incomeValues

incomeDt[,income := c(rep(1,22), rep(2, 15), rep(3, 47), rep(4,38), rep(5, 47), rep(6,45), rep(7,201), rep(8,156), rep(9,73), rep(10,28), rep(11,13), rep(12, 25), rep(1,26), rep(2,25), rep(3,77), rep(4,75), rep(5,69), rep(6,60), rep(7,203), rep(8,95), rep(9,40), rep(10,19), rep(11,10), rep(12, 11))]
incomeValues
incomeDt[, .N,by = .(sample, income)]

toMerge<- pingSubset[, .N, by =.(income, income3)]
toMerge<- toMerge%>%arrange(income)
incomeDt <- left_join(incomeDt, toMerge)

glimpse(incomeDt)

incomeDt[sample == "us_pop",sample := "United States Population"]
names(incomeDt)[1] <- "Income"

densityplot(~Income, group = sample, data = incomeDt, auto.key = TRUE)

#density plot
ggplot(incomeDt) +
  geom_density(aes(x = Income, color = sample))+
    labs(title = "Income distributions:\nSample vs. United States population", y = "Density") +
    scale_x_continuous(breaks = seq(1,11)) +
  theme(legend.title=element_blank())

#density plot
glimpse(incomeDt)

density <- ggplot(incomeDt) +
  geom_density(aes(x = Income, fill = sample), alpha = 0.5)+
  scale_x_continuous(breaks = seq(1,12)) +
  labs(title = "", y = "Density", x = "Income (thousands, USD)") +
  theme(legend.title=element_blank()) +
      scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), labels = c( "4.5", "7.5", "15", "25", "35", "45","75", "125","175", "225", "275", "325")) +
geom_vline(xintercept = 3.96, yintercept = 0, size = 1)  +
  theme(plot.caption = element_text(hjust = 0.5, size  = 10)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 15, colour = 'black'), 
        axis.text.y = element_text(size = 15, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank())+
  guides(fill=FALSE)

#histogram2
histogram <- ggplot(incomeDt, aes(Income, fill = sample)) + 
  geom_histogram(breaks=seq(1, 11, by=1),
                 alpha = 0.5, aes(y = ..density..), position = 'identity') +
    scale_x_continuous(breaks = seq(1,11)) +
    labs(title = "Income distribution of sample vs. United States population", y  = 
           "Density") +
  theme(legend.title=element_blank()) +
        scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), labels = c( "$4,500", "$7,500", "$15,000", "$25,000", "$35,000", "$45,000","$75,000", "$125,000","$175,000", "$225,000", "$275,000", "$325,000")) +
geom_vline(xintercept = 3.96)  +
  guides(fill=FALSE)+  theme(plot.caption = element_text(hjust = 0.5, size  = 10)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 14, colour = 'black'), 
        axis.text.y = element_text(size = 14, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank())+
  guides(fill=FALSE)

incomeHistogram_count <- ggplot(incomeDt, aes(Income, fill = sample)) + 
  geom_histogram(breaks=seq(1, 11, by=1),
                 alpha = 0.5, position = 'identity') +
    scale_x_continuous(breaks = seq(1,11))+
    labs(title = "Income distributions:\nSample vs. United States population", y = "Count") +
  theme(legend.title=element_blank())



```


```{r}

bottom_row <- plot_grid(episodic_z, vocab_z, align = 'h')
plot_grid(density, bottom_row, ncol = 1, rel_heights = c(1, 1.2))
plot_grid(density, episodic_z, vocab_z,align = "hv")

```


```{r}

bottom_row2 <- plot_grid(episodic_residuals, vocab_residuals, align = 'h')
plot_grid(histogram, bottom_row2, ncol = 1, rel_heights = c(1, 1.2))
plot_grid(density, episodic_z, vocab_z,align = "hv")
```


#figure 2b
```{r}

toMerge <- pingSubset[, .(ID, income3)]
dim(toMerge)
AntPostSlopes <- left_join(AntPostSlopes, toMerge)
AntPostSlopes[, .(logIncome3, income3)]


regionImage <- seWithin(data = AntPostSlopes, measurevar = c('volumes_resid'), withinvars = c('region2'),betweenvars = c('income3'), idvar = 'ID')

ggplot(regionImage, aes(income3, volumes_resid, col = region2)) +
    geom_smooth(formula = y ~ log(x), method = 'lm', data = AntPostSlopes)+
  geom_jitter() +
   labs(y = "Adjusted volumes (mm^3; residuals)", x = "Household Income", col = "Region")+
     theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 16, colour = 'black'), 
        axis.text.y = element_text(size = 16, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) +
    scale_x_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000, 300000, 350000), labels = c( "0", "50", "100", "150", "200", "250","300", "350")) 



```

#figure 2b
```{r}

vol_interaction <- ggplot(AntPostSlopes, aes(income3, volumes_resid, col = region2)) +
    geom_smooth(formula = y ~ log(x), method = 'lm', data = AntPostSlopes)+
  #geom_quasirandom(alpha = 0.2) +
   labs(y = "Adjusted volumes \n(mm^3; residuals)", x = "Income (thousands, USD)", col = "Region")+
     theme(legend.position = "none", plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 16, colour = 'black'), 
        axis.text.y = element_text(size = 16, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) +
    scale_x_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000, 300000, 350000), labels = c( "0", "50", "100", "150", "200", "250","300", "350")) #+
  #coord_cartesian(ylim = c(-1000, 1000))


place_holder_figure <- ggplot(AntPostSlopes, aes(income3, volumes_resid, col = region2))

```

#figure 3c&d

```{r}
toMerge <- pingSubset[, .(ID, TBX_ibam_scr_residuals, TBX_VOCAB_THETA_residuals)]
toMerge[, mean(TBX_VOCAB_THETA_residuals, na.rm=TRUE)]
AntPostSlopes <- left_join(AntPostSlopes, toMerge)
AntPostSlopes[region == "combinedPosteriorNewRO", region_name := "Posterior"]
AntPostSlopes[region == "combinedHeadNewRO", region_name := "Anterior"]

episodic_vols <- ggplot(AntPostSlopes, aes(volume, TBX_ibam_scr_residuals, col = region_name)) +
    geom_smooth(formula = y ~ x, method = 'lm', data = AntPostSlopes)+
  #geom_quasirandom(alpha = 0.2) +
   labs(y = "Adjusted episodic memory\n performance", x = "Volume (mm^3)", col = " ")+
     #theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 16, colour = 'black'), 
        axis.text.y = element_text(size = 16, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank()) +
    guides(fill=FALSE)


vocab_vols <- ggplot(AntPostSlopes, aes(volume, TBX_VOCAB_THETA_residuals, col = region_name)) +
    geom_smooth(formula = y ~ x, method = 'lm', data = AntPostSlopes)+
  #geom_quasirandom(alpha = 0.2) +
   labs(y = "Adjusted vocabulary\n performance", x = "Volume (mm^3)", col = " ")+
     #theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(legend.position = "none", panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 16, colour = 'black'), 
        axis.text.y = element_text(size = 16, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) 

bottom_row_vols <- plot_grid(episodic_vols, vocab_vols, align = 'h')
top_row_figs <- plot_grid(place_holder_figure, vol_interaction, align = "h")
plot_grid(top_row_figs, bottom_row_vols, ncol = 1, rel_heights = c(1, 1))


pingSubset[, .(episodic_zscores, TBX_ibam_scr_residuals, TBX_ibam_scr_residualsCheck)]  
pingSubset[!is.na(TBX_ibam_scr), TBX_ibam_scr_residualsCheck := residuals(lm(TBX_ibam_scr ~ AgeC + GenderEC))]
pingSubset[, sum(episodic_zscores, na.rm=TRUE)]


```


```{r}

pingSubset[, ]

grep(names(pingSubset), pattern = "head", value = TRUE)
grep(names(pingSubset), pattern = "tail", value = TRUE)


right.headNewRO
left.headNewRO
right.tailNewRO
left.tailNewRO

pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO), .(left.headNewRO)]


summary(lm(TBX_ibam_scr ~ left.headNewRO + AgeC + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO),]))
summary(lm(TBX_ibam_scr ~ right.headNewRO + AgeC + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO),]))

summary(lm(TBX_VOCAB_THETA ~ left.headNewRO + AgeC + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO),]))
summary(lm(TBX_VOCAB_THETA ~ right.headNewRO + AgeC + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO),]))

summary(lm(TBX_ibam_scr ~ left.tailNewRO + AgeC + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO),]))
summary(lm(TBX_ibam_scr ~ right.tailNewRO + AgeC + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO),]))

summary(lm(TBX_VOCAB_THETA ~ left.tailNewRO + AgeC + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset[!is.na(combinedHeadNewRO)  & !is.na(combinedPosteriorNewRO),]))
summary(lm(TBX_VOCAB_THETA ~ right.tailNewRO + AgeC + logIncome3 + GenderEC + DeviceSerialNumber, data = pingSubset[!is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO),]))



```

```{r}

pingSubset[!is.na(TBX_ibam_scr) & !is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO) &!is.na(logIncome3), .N]
pingSubset[!is.na(TBX_VOCAB_THETA) & !is.na(combinedHeadNewRO) & !is.na(combinedPosteriorNewRO) &!is.na(logIncome3), .N]

```

```{r}
hist(pingSubset$combinedHeadNewRO)
hist(pingSubset$combinedPosteriorNewRO)
hist(pingSubset$logIncome3)
hist(pingSubset$income)

summary(lm(combinedHeadNewRO ~ combinedPosteriorNewRO, data  = pingSubset))


```



#sobel test

```{r}
library(bda)

mediation.model <- mediation.test(mv = pingSubset[!is.na(combinedHeadNewRO_residualized) & !is.na(TBX_VOCAB_THETA_residuals)]$aHipp_residuals, iv =pingSubset[!is.na(combinedHeadNewRO_residualized) & !is.na(TBX_ibam_scr_residuals)]$logIncome, dv =pingSubset[!is.na(combinedHeadNewRO_residualized) & !is.na(TBX_ibam_scr_residuals)]$memory_residuals )

summary(mediation.model)



pingSubset$memory_residuals <- NULL
pingSubset[!is.na(TBX_ibam_scr), memory_residuals := residuals(lm(TBX_ibam_scr ~ AgeC + GenderEC))]

pingSubset[!is.na(TBX_VOCAB_THETA), vocab_residuals := residuals(lm(TBX_VOCAB_THETA ~ AgeC + GenderEC))]


pingSubset[!is.na(combinedHeadNewRO), aHipp_residuals := residuals(lm(combinedHeadNewRO ~ AgeC + GenderEC + DeviceSerialNumber))]



```


```{r}
library(boot)
  
summary(lm(TBX_ibam_scr ~ logIncome3 + AgeC + GenderEC, pingSubset))

```

```{r}

ggplot(pingSubset, aes(Age,TBX_ls, col = Income)) + 
  stat_smooth(method = 'lm', formula = y ~ x, se = TRUE)

ggplot(pingSubset, aes(Age, TBX_dccs_score_scaled, col = Income)) + 
  stat_smooth(method = 'lm', formula = y ~ poly(x,2), se = TRUE)

ggplot(pingFull[!is.na(Income)], aes(TBX_ls_scaled, TBX_dccs_score_scaled, col = Income)) + 
  geom_point()+
  stat_smooth(method = 'lm', formula = y ~ x, se = TRUE)

summary(lm(TBX_ls_scaled ~ TBX_ibam_scr_scaled, data = pingFull))

pingFull[!is.na(income)]

pingFull[, TBX_ls_scaled := scale(TBX_ls)]
pingFull[, TBX_dccs_score_scaled := scale(TBX_dccs_score)]
pingFull[, TBX_ibam_scr_scaled := scale(TBX_ibam_scr)]



ggplot(pingSubset, aes(Age, TBX_pspac_scr, col = Income)) + 
  stat_smooth(method = 'lm', formula = y ~ poly(x,2), se = TRUE)

ggplot(pingSubset, aes(Age, TBX_attention_score, col = Income)) + 
  stat_smooth(method = 'lm', formula = y ~ poly(x,2), se = TRUE)





pingSubset[, .(Income, income2, income3, income)]
pingSubset[, .N, by = .(income3, Income)]
pingSubset[income3 == 35000, Income := "medium"]
  
ggplot(pingFull, aes(Age, WholeHippoNCRO, col = Gender)) +
  geom_point() + 
  stat_smooth(method = 'lm', formula = y ~ poly(x,2), se = TRUE)

```


```{r}
pingSubset[!is.na(combinedHeadNewRO), mean(Age, na.rm=T)]
pingSubset[!is.na(combinedHeadNewRO) & !is.na(logIncome3) & !is.na(combinedPosteriorNewRO), sd(income3, na.rm=T)]

```



```{r}
incomeOnly <- lm(TBX_ibam_scr ~ logIncome3 * AgeC + GenderEC, data = pingSubset[!is.na(combinedPosteriorNewRO) & !is.na(combinedHeadNewRO)])
income_volume <- lm(TBX_ibam_scr ~ logIncome3 + combinedHeadNewRO + AgeC + GenderEC, data = pingSubset[!is.na(combinedPosteriorNewRO) & !is.na(combinedHeadNewRO)])


summary(combinedHeadNewRO ~ logIncome3 + )
summary(incomeOnly)
summary(income_volume)

anova(incomeOnly, income_volume)

```



#figure for brain canada presentation

```{r}

density_BC <- ggplot(incomeDt[sample == "Sample"]) +
  geom_density(aes(x = Income, fill = sample), alpha = 0.5)+
  scale_x_continuous(breaks = seq(1,12)) +
  labs(title = "", y = "Density", x = "Income (thousands, USD)") +
  theme(legend.title=element_blank()) +
      scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), labels = c( "4.5", "7.5", "15", "25", "35", "45","75", "125","175", "225", "275", "325")) +
  theme(plot.caption = element_text(hjust = 0.5, size  = 10)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 15, colour = 'black'), 
        axis.text.y = element_text(size = 15, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank())+
  guides(fill=FALSE)
```

Brain canada family income relates to cognition figures


```{r}

episodic_z_BC <- ggplot(pingSubset, aes(income3, episodic_zscores))+
  geom_jitter(show.legend = FALSE, size = 3, shape = 21)+
  geom_smooth(method = 'lm', formula = y ~ log(x), se = TRUE, shape =1, color = "purple") +
  labs(y = "Adjusted memory", x = 'Income (thousands, USD)') + 
  theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 16, colour = 'black'), 
        axis.text.y = element_text(size = 16, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) +
    scale_x_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000, 300000, 350000), labels = c( "0", "50", "100", "150", "200", "250","300", "350")) +
 scale_y_continuous(breaks=seq(-4, 4, 1))
```


```{r}


vocab_z_BC <- ggplot(pingSubset, aes(income3, vocab_z)) +
  geom_jitter(show.legend = FALSE, size = 3, shape = 21)+
  geom_smooth(method = 'lm', formula = y ~ log(x), se = TRUE, shape =1, color = "darkgreen") +
  labs(y = "Adjusted vocabulary", x = 'Income (thousands, USD)') + 
   theme(plot.caption = element_text(hjust = -.2, size  = 12)) +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white", colour = NA),
        axis.line.x = element_line(size = 1, linetype = "solid", colour = "black"), 
        axis.line.y = element_line(size = 1, linetype = "solid", colour = "black"),
        axis.text.x = element_text(size = 16, colour = 'black'), 
        axis.text.y = element_text(size = 16, colour = 'black'), 
        plot.title = element_text(size = 15, hjust = 0.5),
        text = element_text(size = 15), panel.spacing.x = unit(1, "lines"),
        legend.key = element_blank(), legend.key.height = unit(2, 'line')) +
    scale_x_continuous(breaks = c(0, 50000, 100000, 150000, 200000, 250000, 300000, 350000), labels = c( "0", "50", "100", "150", "200", "250","300", "350")) +
 scale_y_continuous(breaks=seq(-4, 4, 1))



```


```{r}
library(cowplot)
income_cognition_bc_plot <- plot_grid(episodic_z_BC, vocab_z_BC, align = 'h')
```


```

